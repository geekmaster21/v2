

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Inline Encryption &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: ''
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.14.266
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x86/index.html">x86 architecture specifics</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Inline Encryption</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/block/inline-encryption.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="inline-encryption">
<h1>Inline Encryption<a class="headerlink" href="#inline-encryption" title="Permalink to this headline">¶</a></h1>
<div class="section" id="objective">
<h2>Objective<a class="headerlink" href="#objective" title="Permalink to this headline">¶</a></h2>
<p>We want to support inline encryption (IE) in the kernel.
To allow for testing, we also want a crypto API fallback when actual
IE hardware is absent. We also want IE to work with layered devices
like dm and loopback (i.e. we want to be able to use the IE hardware
of the underlying devices if present, or else fall back to crypto API
en/decryption).</p>
</div>
<div class="section" id="constraints-and-notes">
<h2>Constraints and notes<a class="headerlink" href="#constraints-and-notes" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>IE hardware have a limited number of &#8220;keyslots&#8221; that can be programmed
with an encryption context (key, algorithm, data unit size, etc.) at any time.
One can specify a keyslot in a data request made to the device, and the
device will en/decrypt the data using the encryption context programmed into
that specified keyslot. When possible, we want to make multiple requests with
the same encryption context share the same keyslot.</li>
<li>We need a way for filesystems to specify an encryption context to use for
en/decrypting a struct bio, and a device driver (like UFS) needs to be able
to use that encryption context when it processes the bio.</li>
<li>We need a way for device drivers to expose their capabilities in a unified
way to the upper layers.</li>
</ul>
</div>
<div class="section" id="design">
<h2>Design<a class="headerlink" href="#design" title="Permalink to this headline">¶</a></h2>
<p>We add a struct bio_crypt_ctx to struct bio that can represent an
encryption context, because we need to be able to pass this encryption
context from the FS layer to the device driver to act upon.</p>
<p>While IE hardware works on the notion of keyslots, the FS layer has no
knowledge of keyslots - it simply wants to specify an encryption context to
use while en/decrypting a bio.</p>
<p>We introduce a keyslot manager (KSM) that handles the translation from
encryption contexts specified by the FS to keyslots on the IE hardware.
This KSM also serves as the way IE hardware can expose their capabilities to
upper layers. The generic mode of operation is: each device driver that wants
to support IE will construct a KSM and set it up in its struct request_queue.
Upper layers that want to use IE on this device can then use this KSM in
the device&#8217;s struct request_queue to translate an encryption context into
a keyslot. The presence of the KSM in the request queue shall be used to mean
that the device supports IE.</p>
<p>On the device driver end of the interface, the device driver needs to tell the
KSM how to actually manipulate the IE hardware in the device to do things like
programming the crypto key into the IE hardware into a particular keyslot. All
this is achieved through the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">keyslot_mgmt_ll_ops</span></code> that the
device driver passes to the KSM when creating it.</p>
<p>It uses refcounts to track which keyslots are idle (either they have no
encryption context programmed, or there are no in-flight struct bios
referencing that keyslot). When a new encryption context needs a keyslot, it
tries to find a keyslot that has already been programmed with the same
encryption context, and if there is no such keyslot, it evicts the least
recently used idle keyslot and programs the new encryption context into that
one. If no idle keyslots are available, then the caller will sleep until there
is at least one.</p>
</div>
<div class="section" id="blk-crypto">
<h2>Blk-crypto<a class="headerlink" href="#blk-crypto" title="Permalink to this headline">¶</a></h2>
<p>The above is sufficient for simple cases, but does not work if there is a
need for a crypto API fallback, or if we are want to use IE with layered
devices. To these ends, we introduce blk-crypto. Blk-crypto allows us to
present a unified view of encryption to the FS (so FS only needs to specify
an encryption context and not worry about keyslots at all), and blk-crypto
can decide whether to delegate the en/decryption to IE hardware or to the
crypto API. Blk-crypto maintains an internal KSM that serves as the crypto
API fallback.</p>
<p>Blk-crypto needs to ensure that the encryption context is programmed into the
&#8220;correct&#8221; keyslot manager for IE. If a bio is submitted to a layered device
that eventually passes the bio down to a device that really does support IE, we
want the encryption context to be programmed into a keyslot for the KSM of the
device with IE support. However, blk-crypto does not know a priori whether a
particular device is the final device in the layering structure for a bio or
not. So in the case that a particular device does not support IE, since it is
possibly the final destination device for the bio, if the bio requires
encryption (i.e. the bio is doing a write operation), blk-crypto must fallback
to the crypto API <em>before</em> sending the bio to the device.</p>
<p>Blk-crypto ensures that:</p>
<ul class="simple">
<li>The bio&#8217;s encryption context is programmed into a keyslot in the KSM of the
request queue that the bio is being submitted to (or the crypto API fallback
KSM if the request queue doesn&#8217;t have a KSM), and that the <code class="docutils literal"><span class="pre">bc_ksm</span></code>
in the <code class="docutils literal"><span class="pre">bi_crypt_context</span></code> is set to this KSM</li>
<li>That the bio has its own individual reference to the keyslot in this KSM.
Once the bio passes through blk-crypto, its encryption context is programmed
in some KSM. The &#8220;its own individual reference to the keyslot&#8221; ensures that
keyslots can be released by each bio independently of other bios while
ensuring that the bio has a valid reference to the keyslot when, for e.g., the
crypto API fallback KSM in blk-crypto performs crypto on the device&#8217;s behalf.
The individual references are ensured by increasing the refcount for the
keyslot in the <code class="docutils literal"><span class="pre">bc_ksm</span></code> when a bio with a programmed encryption
context is cloned.</li>
</ul>
<div class="section" id="what-blk-crypto-does-on-bio-submission">
<h3>What blk-crypto does on bio submission<a class="headerlink" href="#what-blk-crypto-does-on-bio-submission" title="Permalink to this headline">¶</a></h3>
<p><strong>Case 1:</strong> blk-crypto is given a bio with only an encryption context that hasn&#8217;t
been programmed into any keyslot in any KSM (for e.g. a bio from the FS).</p>
<blockquote>
<div>In this case, blk-crypto will program the encryption context into the KSM of the
request queue the bio is being submitted to (and if this KSM does not exist,
then it will program it into blk-crypto&#8217;s internal KSM for crypto API
fallback). The KSM that this encryption context was programmed into is stored
as the <code class="docutils literal"><span class="pre">bc_ksm</span></code> in the bio&#8217;s <code class="docutils literal"><span class="pre">bi_crypt_context</span></code>.</div></blockquote>
<p><strong>Case 2:</strong> blk-crypto is given a bio whose encryption context has already been
programmed into a keyslot in the <em>crypto API fallback</em> KSM.</p>
<blockquote>
<div>In this case, blk-crypto does nothing; it treats the bio as not having
specified an encryption context. Note that we cannot do here what we will do
in Case 3 because we would have already encrypted the bio via the crypto API
by this point.</div></blockquote>
<p><strong>Case 3:</strong> blk-crypto is given a bio whose encryption context has already been
programmed into a keyslot in some KSM (that is <em>not</em> the crypto API fallback
KSM).</p>
<blockquote>
<div>In this case, blk-crypto first releases that keyslot from that KSM and then
treats the bio as in Case 1.</div></blockquote>
<p>This way, when a device driver is processing a bio, it can be sure that
the bio&#8217;s encryption context has been programmed into some KSM (either the
device driver&#8217;s request queue&#8217;s KSM, or blk-crypto&#8217;s crypto API fallback KSM).
It then simply needs to check if the bio&#8217;s <code class="docutils literal"><span class="pre">bc_ksm</span></code> is the device&#8217;s
request queue&#8217;s KSM. If so, then it should proceed with IE. If not, it should
simply do nothing with respect to crypto, because some other KSM (perhaps the
blk-crypto crypto API fallback KSM) is handling the en/decryption.</p>
<p>Blk-crypto will release the keyslot that is being held by the bio (and also
decrypt it if the bio is using the crypto API fallback KSM) once
<code class="docutils literal"><span class="pre">bio_remaining_done</span></code> returns true for the bio.</p>
</div>
</div>
<div class="section" id="layered-devices">
<h2>Layered Devices<a class="headerlink" href="#layered-devices" title="Permalink to this headline">¶</a></h2>
<p>Layered devices that wish to support IE need to create their own keyslot
manager for their request queue, and expose whatever functionality they choose.
When a layered device wants to pass a bio to another layer (either by
resubmitting the same bio, or by submitting a clone), it doesn&#8217;t need to do
anything special because the bio (or the clone) will once again pass through
blk-crypto, which will work as described in Case 3. If a layered device wants
for some reason to do the IO by itself instead of passing it on to a child
device, but it also chose to expose IE capabilities by setting up a KSM in its
request queue, it is then responsible for en/decrypting the data itself. In
such cases, the device can choose to call the blk-crypto function
<code class="docutils literal"><span class="pre">blk_crypto_fallback_to_kernel_crypto_api</span></code> (TODO: Not yet implemented), which will
cause the en/decryption to be done via the crypto API fallback.</p>
</div>
<div class="section" id="future-optimizations-for-layered-devices">
<h2>Future Optimizations for layered devices<a class="headerlink" href="#future-optimizations-for-layered-devices" title="Permalink to this headline">¶</a></h2>
<p>Creating a keyslot manager for the layered device uses up memory for each
keyslot, and in general, a layered device (like dm-linear) merely passes the
request on to a &#8220;child&#8221; device, so the keyslots in the layered device itself
might be completely unused. We can instead define a new type of KSM; the
&#8220;passthrough KSM&#8221;, that layered devices can use to let blk-crypto know that
this layered device <em>will</em> pass the bio to some child device (and hence
through blk-crypto again, at which point blk-crypto can program the encryption
context, instead of programming it into the layered device&#8217;s KSM). Again, if
the device &#8220;lies&#8221; and decides to do the IO itself instead of passing it on to
a child device, it is responsible for doing the en/decryption (and can choose
to call <code class="docutils literal"><span class="pre">blk_crypto_fallback_to_kernel_crypto_api</span></code>). Another use case for the
&#8220;passthrough KSM&#8221; is for IE devices that want to manage their own keyslots/do
not have a limited number of keyslots.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright The kernel development community.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>